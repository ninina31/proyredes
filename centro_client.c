/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "centro.h"
#ifndef MT
#define MT 480
#endif

struct Server{
    
    char distCenter[41];
    int port;
    char host[128];
    int time;
    struct Server *next;
};

typedef struct Server bestServer;

struct List {

    bestServer *begin;
    bestServer *end;
    int size;
};

typedef struct List list;

void inicializeList(list *target){

    (*target).begin = NULL;
    (*target).end = NULL;
    (*target).size = 0;
}

void addList(list *target, bestServer *object){

    bestServer *temp = (*target).begin;
    bestServer *temp2 = (*temp).next;
    int n = 0;

    if ((*target).size == 0){
        (*target).begin = object;
        (*target).end = object;
        (*object).next = NULL;
        (*target).size = 1;
        n = 1;
        temp = NULL;
    }

    while(temp2 != NULL){
        if ((*temp2).time >= (*object).time){
            (*object).next = (*temp2).next;
            (*temp).next = object;
            n = 1;
            break;
        }
        temp = temp2;
        temp2 = (*temp2).next;
    }

    if (n == 0){
        (*target).end = object;
        (*object).next = NULL;
    }

    (*target).size += 1;
}

void errorControler(const char *msg){
    perror(msg);
    exit(1);
}

list *seekBestTime(char CentersFile[]){
    
    FILE *fp;

    list *result;
    bestServer *tempitem;

    char ip[41];
    char distCenter[41];
    int port;
    int n, i;

    int bestTime = 0;

    fp = fopen(CentersFile, "r");

    CLIENT *clnt;
    int  *result_1;

    if (fp != NULL){
        
        while (feof(fp) == 0){

            n = fscanf(fp, "%[^&]&%[^&]&%d\n", distCenter, ip, &port);

            tempitem = (bestServer *)malloc(sizeof(bestServer));

            clnt = clnt_create (ip, CENTRO_PROG, CENTRO_VERS, "udp");
            if (clnt != NULL) {

                result_1 = askfortime_1(NULL, clnt);

                bestTime = *result_1;

                strcpy((*tempitem).distCenter,distCenter);
                (*tempitem).time = bestTime;
                strcpy((*tempitem).host,ip);
                (*tempitem).port = port;

                addList(result, tempitem);

                clnt_destroy (clnt);

            }
        }

    } else{
       errorControler("Error abriendo archivo de centros de distribucion\n");
    }

    if(fclose(fp)){
       errorControler( "Error: archivo no cerrado\n");
    }

    return result;
}

/*
* Funcion askForGas: retorna el tiempo que tarda en hacer una solicitud. Se intenta conectar con el centro de distribución guardado en la estructura para pedir suministro de gasolina. Si el centro esta caído, se escribe en el archivo de reporte el evento, se elige otro centro de distribución y se vuelve a intentar la conexión. Si el centro de distribución responde que no tiene inventario para suplir, se escribe en el archivo de reporte el evento, se busca otro centro de distribución y se hace la petición. Si tiene inventario, se escribe en el archivo de reporte el evento, se rompe el ciclo y se sale de la función.

Entrada:
    @ orig:Apuntador a la estructura donde se almacena el centro de distribucion con mejor tiempo de respuesta.
    @ CentersFile: Nombre del archivo que contiene la informacion de los centros de distribucion.
    @ report: File Descriptor del archivo de reporte.
    @ gasStation: Nombre de la bomba de gasolina.

Salida: tiempo de respuesta de la peticion de suministro de gasolina.

*/

int askForGas(bestServer **orig, list *servers, char CentersFile[], FILE *report, int elapsedTime, char *gasStation){

    int bool = 0;
    int respuesta = 0;

    time_t begin;
    time_t end;
    int timeSpent;

    time_t bMeasureTime;
    time_t eMeasureTime;

    int totalTime = elapsedTime;

    bestServer **best = orig;

    int n;

    CLIENT *clnt;
    int  *result_2;

    begin = time(NULL);

    while(bool == 0 && totalTime < MT){

        bMeasureTime = time(NULL);

        clnt = clnt_create ((**best).distCenter, CENTRO_PROG, CENTRO_VERS, "udp");

        if (clnt == NULL){

            printf("El centro con mejor respuesta no esta disponible, buscando el siguiente...\n");

            end = time(NULL);
            timeSpent = (int)(end - begin)*10;
            n = elapsedTime + timeSpent;
            fprintf(report, "Peticion: %d minutos, %s, Sin Respuesta.\n\n", n, (**best).distCenter);
            n = (**best).port;

            if((**best).next == NULL)
                *best = (*servers).begin;
            else
                *best = (**best).next;
        }

        end = time(NULL);
        timeSpent = (int)(end - begin);
        n = elapsedTime + timeSpent;

        result_2 = askforsupply_1(gasStation, clnt);

        respuesta = *result_2;

        if (respuesta == 0){
            fprintf(report, "Peticion: %d minutos, %s, OK.\n\n", n, (**best).distCenter);
            bool = 1;

        } else {
            fprintf(report, "Peticion: %d minutos, %s, Sin inventario.\n\n", n, (**best).distCenter);

            printf("El centro me respondio que no tiene suministro, buscando otro centro...\n");

            if((**best).next == NULL)
                *best = (*servers).begin;
            else
                *best = (**best).next;
        }

        clnt_destroy (clnt);
        eMeasureTime = time(NULL);

        totalTime += (int)(eMeasureTime - bMeasureTime);

    }

    end = time(NULL);

    timeSpent = (int)(end - begin)*10;

    return timeSpent;
}

void
centro_prog_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	char *askfortime_1_arg;
	int  *result_2;
	char  askforsupply_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, CENTRO_PROG, CENTRO_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = askfortime_1((void*)&askfortime_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_2 = askforsupply_1(&askforsupply_1_arg, clnt);
	if (result_2 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *gasStation = (char*)malloc(sizeof(char)*255);
    int cp = 0;
    int i = 0;
    int c = 0;
    char* CentersFile;
    int count = 0;
    int elapsedTime = 0;
    time_t begin;
    time_t end;

    FILE *report;
    char fileName[51] = "log_";

    double missingTime = 0.0;
    int missingGas = 0;
    double sust = 0.0;

    list *best;
    bestServer *currentServer;

    if (argc != 11) {
       errorControler("El numero de argumentos es invalido, abortando...\n");
    }

    for (count = 0; count < 5; ++count){

        if (strcmp(argv[count*2 + 1],"-n") == 0){
	    gasStation = argv[count*2 + 2];
            continue;
        } else if (strcmp(argv[count*2 + 1],"-cp") == 0){
            cp = atoi(argv[count*2 + 2]);
            if (!(38000 <= cp  && cp <= 3800000)){
                errorControler("La capacidad maxima debe estar entre 38.000 y 3.800.000 l\n");
            }
            continue;
        } else if (strcmp(argv[count*2 + 1],"-i") == 0){
            i = atoi(argv[count*2 + 2]);
            if (!(0 <= i && i <= cp)){
                errorControler("En inventario debe estar entre 0 y la capacidad maxima\n");
            }
            continue;
        } else if (strcmp(argv[count*2 + 1],"-c") == 0){
            c = atoi(argv[count*2 + 2]);
            if (!(0 <= c && c <= 1000)){
                errorControler("El consumo promedio debe estar entre 0 y 1.000l/min\n");
            }
            continue;
        } else if (strcmp(argv[count*2 + 1],"-fc") == 0){
            CentersFile = argv[count*2 + 2];
        }
    }

    begin = time(NULL);

    best = seekBestTime(CentersFile);

    currentServer = (*best).begin;

    strcat(fileName, gasStation);
    strcat(fileName, ".txt");
    report = fopen(fileName,"w+");

    if (report == NULL){
        errorControler("Error abriendo el archivo de reporte\n");
    }
    
    fprintf(report, "Eventos Importantes\n\n", i);

    fprintf(report, "Inventario Inicial: %d litros.\n\n", i);

    end = time(NULL);

    elapsedTime = (int) (end - begin);
    
    while( elapsedTime < MT ){

        printf("Tiempo Transcurrido: %d\n", elapsedTime);
        printf("Inventario: %d\n", i);

        missingGas = cp - i;

        if (missingGas >= 38000){

            printf("Tengo espacio para mas gasolina, pedire suministro\n");

	    if (i == 0){
                fprintf(report, "Tanque vacio: %d minutos.\n\n", elapsedTime);
            }
            
            elapsedTime += askForGas(&currentServer, best, CentersFile, report, elapsedTime, gasStation);
            sleep((*currentServer).time*0.10);

            elapsedTime += (*currentServer).time;

            i += 38000;

            fprintf(report, "Llegada de la gandola: %d minutos, %d litros.\n\n", elapsedTime, i);
            
        } else {

            printf("No tengo espacio para mas gasolina, esperare...\n");
	    
	       if (i == cp){
                fprintf(report, "Tanque full: %d minutos.\n\n", elapsedTime);
            }

            if (c != 0){
                missingTime = (double)(38000 - missingGas) / c;
                sust = missingTime - (*currentServer).time;
            } else {
                missingTime = 0;
            }
	     
            if (sust < 0.0){

                elapsedTime += askForGas(&currentServer, best, CentersFile, report, elapsedTime, gasStation);
                sleep((*currentServer).time*0.10);
                elapsedTime = elapsedTime + (*currentServer).time;

                i -= (*currentServer).time*c;
                i += 38000;

            } else if (sust == 0.0){
                sleep((MT - elapsedTime)*0.10);
            } else {

                sleep(sust*0.10);
        		elapsedTime += sust;
        		i -= (sust)*c;
        		elapsedTime += askForGas(&currentServer, best, CentersFile, report, elapsedTime, gasStation);
        		sleep((*currentServer).time*0.10);
                elapsedTime += (*currentServer).time;
                i -= (*currentServer).time*c;
                i += 38000;
            }
        }

    }

    if( !fclose(report) )
      printf( "Archivo de reportes listo para ser leido\n" );
	else {
      errorControler( "Error: archivo de reporte no se ha cerrado\n" );
	}

    currentServer = (*best).begin;
    bestServer *temp = (*currentServer).next;

	while(currentServer != NULL){
        free(currentServer);
        currentServer = temp;
        if (temp != NULL){
            temp = (*temp).next;
        }
    }

	return (0);
}
