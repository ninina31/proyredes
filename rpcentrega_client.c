/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

/*sudo ./rpcentrega_server -n CD1 -cp 100000 -i 50000 -s 1000 -t 60
sudo ./rpcentrega_client -n B1 -cp 100000 -i 50000 -c 0 -fc file.txt*/

#include "rpcentrega.h"
#include "crypto.h"

#ifndef MT
#define MT 480 
#endif

#include <pthread.h>

int executionTime = 0;
int inventory;

struct Server{
    
    char distCenter[50];
    int port;
    char host[128];
    int time;
    struct Server *next;
};

typedef struct Server bestServer;

struct List {

    bestServer *begin;
    bestServer *end;
    int size;
};

typedef struct List list;

void inicializeList(list *target){

    (*target).begin = NULL;
    (*target).end = NULL;
    (*target).size = 0;
}

void addList(list *target, bestServer *object){

    bestServer *temp = (*target).begin;
    bestServer *temp2;

    int n = 0;

    if ((*target).size == 0){
        (*target).begin = object;
        (*target).end = object;
        (*object).next = NULL;
        (*target).size = 1;
        n = 1;
        temp = NULL;
    } else {

        while(temp2 != NULL){
            if ((*temp2).time >= (*object).time){
                (*object).next = (*temp2).next;
                (*temp).next = object;
                n = 1;
                break;
            }
            temp = temp2;
            temp2 = (*temp2).next;
        }
    }

    if (n == 0){
        (*target).end = object;
        (*object).next = NULL;
    }

    (*target).size += 1;
}

list *seekBestTime(char CentersFile[]){
    
    FILE *fp;

    list *result = (list *)malloc(sizeof(list));
    inicializeList(result);

    bestServer *tempitem;

    char ip[41];
    char distCenter[41];
    int port;
    int n;

    int bestTime = 0;

    fp = fopen(CentersFile, "r");

    CLIENT *clnt;
    int  *result_1;

    if (fp != NULL){
        
        while (feof(fp) == 0 && executionTime < MT){

            n = fscanf(fp, "%[^&]&%[^&]&%d\n", distCenter, ip, &port);

            tempitem = (bestServer *)malloc(sizeof(bestServer));

            clnt = clnt_create (ip, RPCENTREGA_PROG, RPCENTREGA_VERS, "udp");

            if (clnt == NULL) {
                printf("El centro en el host %s no esta disponible, siguiente centro...\n", ip);
                printf("executionTime: %d\n", executionTime);
            } else {

                result_1 = askfortime_1(NULL, clnt);

                if (result_1 != (int *) NULL) {

                    bestTime = *result_1;

                    strcpy((*tempitem).distCenter, distCenter);

                    (*tempitem).time = bestTime;
                    strcpy((*tempitem).host,ip);
                    (*tempitem).port = port;

                    addList(result, tempitem);

                    bzero(distCenter, 42);

                    clnt_destroy (clnt);

                } else {
                    printf("El centro en el host %s no esta disponible, siguiente centro...\n", ip);
                }
            }
        }

    } else{
        perror("Error abriendo archivo de centros de distribucion\n");
        exit(1);
    }

    if(fclose(fp)){
        perror("Error: archivo no cerrado\n");
        exit(1);
    }

    return result;
}

/*
* Funcion askForGas: retorna el tiempo que tarda en hacer una solicitud. Se intenta conectar con el centro de distribución guardado en la estructura para pedir suministro de gasolina. Si el centro esta caído, se escribe en el archivo de reporte el evento, se elige otro centro de distribución y se vuelve a intentar la conexión. Si el centro de distribución responde que no tiene inventario para suplir, se escribe en el archivo de reporte el evento, se busca otro centro de distribución y se hace la petición. Si tiene inventario, se escribe en el archivo de reporte el evento, se rompe el ciclo y se sale de la función.

Entrada:
    @ orig:Apuntador a la estructura donde se almacena el centro de distribucion con mejor tiempo de respuesta.
    @ CentersFile: Nombre del archivo que contiene la informacion de los centros de distribucion.
    @ report: File Descriptor del archivo de reporte.
    @ gasStation: Nombre de la bomba de gasolina.

Salida: tiempo de respuesta de la peticion de suministro de gasolina.

*/

bestServer* askForGas(bestServer *orig, list **servers, char CentersFile[], FILE *report, char *gasStation){

    int bool = 0;
    int respuesta = 0;

    int *seed; // the seed of the client!
    char key[64] = "clave";

    int c = 0;
    bestServer *best = orig;

    CLIENT *clnt;
    int *result_2;

    //printf("entre a la funcion\n");

    while ((**servers).size == 0 && executionTime < MT){
        *servers = seekBestTime(CentersFile);
    }
    
    while (bool == 0 && executionTime < MT){

        clnt = clnt_create ( (*best).host, RPCENTREGA_PROG, RPCENTREGA_VERS, "udp");

        if (clnt == NULL){
            respuesta = -1;
        }

        /*
        * I have to autentificate the client to stablish the connection.
        */

        seed = autentificarbomba_1( gasStation, clnt ); // now the client have a seed.

        if ( seed == (int *) NULL) {
            respuesta = -1;
        }
        //printf( "Problem with the seed %d", *seed );
        //key = MD5(seed);
        c = (int)*seed;

        strcpy( key, (char *)makeMD5FI( c ) );

        result_2 = (int *)confirm_1( key, clnt);

        if( result_2 != (int *)NULL){ /*Verification have to be a remote function too*/

            if ( result_2 ){
                 result_2 = askforsupply_1( gasStation, clnt );

                if (result_2 == (int *) NULL) {
                    respuesta = -1;
                } else {
                    respuesta = *result_2;
                }
            } else {
                respuesta = 2;
            }
            /* Once that the client is autentificate then he/she can ask for supply */
        } else{
            respuesta = -1;
        }

        if (respuesta == 0){
            fprintf(report, "Peticion: %d minutos, %s, OK.\n\n", executionTime, (*best).distCenter);
            bool = 1;

        } else if (respuesta == 1) {
            fprintf(report, "Peticion: %d minutos, %s, Sin inventario.\n\n", executionTime, (*best).distCenter);

            printf("El centro me respondio que no tiene suministro, buscando otro centro...\n");

            if((*best).next == NULL){
                *servers = seekBestTime(CentersFile);
                best = (**servers).begin;
            } else {
                best = (*best).next;
            }
        } else if (respuesta == 2) {
            fprintf(report, "Peticion: %d minutos, %s, Ticket expirado.\n\n", executionTime, (*best).distCenter);

            //printf("Ticket expirado, repitiendo la peticion...\n");
        }
         else {

            fprintf(report, "Peticion: %d minutos, %s, Sin Respuesta.\n\n", executionTime, (*best).distCenter);

            if((*best).next == NULL){
                *servers = seekBestTime(CentersFile);
                best = (**servers).begin;
            } else {
                best = (*best).next;
            }
        }
        clnt_destroy (clnt);
    }

    return best;
}

void
rpcentrega_prog_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	char *askfortime_1_arg;
	int  *result_2;
	char  askforsupply_1_arg;
	int  *result_3;
	char  autentificarbomba_1_arg;
	int  *result_4;
	char  confirm_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, RPCENTREGA_PROG, RPCENTREGA_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = askfortime_1((void*)&askfortime_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_2 = askforsupply_1(&askforsupply_1_arg, clnt);
	if (result_2 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_3 = autentificarbomba_1(&autentificarbomba_1_arg, clnt);
	if (result_3 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_4 = confirm_1(&confirm_1_arg, clnt);
	if (result_4 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

void *timeHandler(void *c){

    int c1 = *(int *)c;

    int fill = 5*c1;

    while( executionTime < MT ){
        usleep( 500000 );
        executionTime += 5;

        if ((inventory - fill) >= 0){
            inventory -= (int)fill;
        } else {
            inventory = 0;
        }
    }
}

int
main (int argc, char *argv[])
{
	char *gasStation = (char*)malloc(sizeof(char)*50);
    int cp = 0;
    int c = 0;
    char* CentersFile;
    int count = 0;

    FILE *report;
    char fileName[51] = "log_";

    double missingTime = 0.0;
    int missingGas = 0;
    double sust = 0.0;

    list *best = (list *)malloc(sizeof(list));
    bestServer *currentServer;

    pthread_t timeThread;
    void* exit_status;

    if (argc != 11) {
        perror("El numero de argumentos es invalido, abortando...\n");
        exit(1);
    }

    for (count = 0; count < 5; ++count){

        if (strcmp(argv[count*2 + 1],"-n") == 0){
	    gasStation = argv[count*2 + 2];
            continue;
        } else if (strcmp(argv[count*2 + 1],"-cp") == 0){
            cp = atoi(argv[count*2 + 2]);
            if (!(38000 <= cp  && cp <= 3800000)){
                perror("La capacidad maxima debe estar entre 38.000 y 3.800.000 l\n");
                exit(1);
            }
            continue;
        } else if (strcmp(argv[count*2 + 1],"-i") == 0){
            inventory = atoi(argv[count*2 + 2]);
            if (!(0 <= inventory && inventory <= cp)){
                perror("En inventario debe estar entre 0 y la capacidad maxima\n");
                exit(1);
            }
            continue;
        } else if (strcmp(argv[count*2 + 1],"-c") == 0){
            c = atoi(argv[count*2 + 2]);
            if (!(0 <= c && c <= 1000)){
                perror("El consumo promedio debe estar entre 0 y 1.000l/min\n");
                exit(1);
            }
            continue;
        } else if (strcmp(argv[count*2 + 1],"-fc") == 0){
            CentersFile = argv[count*2 + 2];
        }
    }

    pthread_create( &timeThread, NULL, timeHandler, (void *)&c);    

    best = seekBestTime(CentersFile);

    currentServer = (*best).begin;

    strcat(fileName, gasStation);
    strcat(fileName, ".txt");
    report = fopen(fileName,"w+");


    if (report == NULL){
        perror("Error abriendo el archivo de reporte\n");
        exit(1);
    }
    
    fprintf(report, "Eventos Importantes\n\n");

    fprintf(report, "Inventario Inicial: %d litros.\n\n", inventory);
    
    while( executionTime < MT ){

        printf("Tiempo Transcurrido: %d\n", executionTime);
        printf("Inventario: %d\n", inventory);

        missingGas = cp - inventory;

        if (missingGas >= 38000){

            printf("Tengo espacio para mas gasolina, pedire suministro\n");

	    if (inventory == 0){
                fprintf(report, "Tanque vacio: %d minutos.\n\n", executionTime);
            }
            
            currentServer = askForGas(currentServer, &best, CentersFile, report, gasStation);

            if (currentServer != NULL){

                usleep((*currentServer).time*100000);

                fprintf(report, "Llegada de la gandola: %d minutos, %d litros.\n\n", executionTime, inventory);
                inventory += 38000;
            }            
            
        } else {

            printf("No tengo espacio para mas gasolina, esperare...\n");
	    
            if (inventory == cp){
                fprintf(report, "Tanque full: %d minutos.\n\n", executionTime);
            }

            if (currentServer != NULL){

                if (c != 0){
                    missingTime = (double)(38000 - missingGas) / c;
                    sust = missingTime - (*currentServer).time;
                } else {
                    sust = 0.0;
                }
    	     
                if (sust < 0.0){

                    printf("entre en menor que cero\n");

                    currentServer = askForGas(currentServer, &best, CentersFile, report, gasStation);

                    printf("center %s\n", (*currentServer).host);

                    usleep((*currentServer).time*100000);

                    inventory += 38000;

                } else if (sust == 0.0){

                    printf("entre en igual que cero\n");

                    usleep((MT - executionTime)*100000);

                } else {

                    printf("entre en mayor que cero\n");

                    usleep(sust*100000);
            		currentServer = askForGas(currentServer, &best, CentersFile, report, gasStation);

            		usleep((*currentServer).time*100000);
                    inventory += 38000;
                }

            }
        }

    }

    pthread_join(timeThread, &exit_status);

    if( !fclose(report) )
        printf( "Archivo de reportes listo para ser leido\n" );
	else {
        perror( "Error: archivo de reporte no se ha cerrado\n" );
        exit(1);
	}

    if (currentServer != NULL){
        currentServer = (*best).begin;
        bestServer *temp = (*currentServer).next;

        while(currentServer != NULL){
            free(currentServer);
            currentServer = temp;
            if (temp != NULL){
                temp = (*temp).next;
            }
        }
    }

	return (0);
}
